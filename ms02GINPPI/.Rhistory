pairs$essen2 = pairs$id2 %in% essentialORFs
head(pairs)
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove,1:4 ]
#Now, only 31394 intxn left for the original net
# 34052 for one ms02 network
#how many essen <--> essen intxn?
pairs$inxnEE = pairs$essen1 & pairs$essen2
table(pairs$inxnEE)
# FALSE  TRUE
# 28222  3172
#So, EE intxn should only occur in PPI
#for ms02,
#FALSE  TRUE
#33538   514
#How many essen genes?
tmp = essentialORFs %in% unique(c(pairs$id1, pairs$id2))
table(tmp)
#FALSE  TRUE
#110   1048
#104 1048 ???
essentialORFsPPI = essentialORFs[tmp] #?????
#get connectivities per node
degreeTb = data.frame( table(c(pairs[,1], pairs[,2])))
summary(degreeTb)
#median degree =5, mean=12
#for one ms02, media =6, mean=13.68, so orginal network is power-law like, skew at two ends.
degreeTb$ORF = as.character( degreeTb[,1])
#hist(log2(degreeTb$Freq), breaks=30)
degreeCutoff = 4; #######!!!!!! degree=5 is the median
tmp = essentialORFsPPI %in% degreeTb$ORF[degreeTb$Freq>degreeCutoff]
GooddEssentialORFsPPI = essentialORFsPPI[tmp]
###########################
if(debug >= 5){GooddEssentialORFsPPI = GooddEssentialORFsPPI[1:100]  }
###########################
# simulate aging
# -> exponential age to all pairs
# -> maximal age for each essential gene
# -> minimal age for all essential modules
#set.seed(2013)
#lambda_v = 1 / 3^seq(3,5)
#lambda_v = 1 / s
lambda_v = 1/c(27, 27*3)
# Notice that degree*p > 1 if the cells are to be alive. >2 should sufficient redundancy.
p_v = seq(0.7, 1.0, by=0.1)  ; #the chance that each gene interaction is active at t=0
#p_v = c(0.7, 0.7, 0.7,  0.8, 0.8, 0.8, 0.9, 0.9, 0.9, 1.0, 1.0, 1.0)  ; #the chance that each gene interaction is active at t=0
sim_names = c( "degreeCutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
sim       = t( c(NA,     NA,   NA,       NA,       NA,        NA,  NA,   NA,      NA))
sim = data.frame(sim)
names(sim) = sim_names
################################## network simulations
# for debug, lambda = 1/10
# lambda = 1/35; p=0.9
for(lambda in lambda_v) {
# p=0.9, #for debug
for( p in p_v) {
popSize = 10 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*100)) {
count = count + 1;
#runningORFs = GooddEssentialORFsPPI
currentNetworkAge = _single_network_failure(lambda, p, pairs, GoodEssentialORFsPPI)
#single_network_failure = function(lambda, p, pairs, runningORFs) {
if (currentNetworkAge > 0) {
popAges[j] = currentNetworkAge
j = j+1
}
}# end of j while-loop, population loop
#time2 = date()
#hist(popAges)
#summary(popAges)
#popAges = popAges[popAges>0]; #remove dead-births, which can occur when p is low
#time1; time2;
#s.tb = calculate.s ( popAges )
#plot( s.tb$s ~ s.tb$t )
#plot( s.tb$s ~ s.tb$t, type='l', log='x' )
#lifespanGomp = flexsurvreg(formula = Surv(popAges) ~ 1, dist = 'gompertz') ### Use the flexsurvreg package to fit lifespan data to gompertz or weibull distribution
#lifespanWeib = flexsurvreg(formula = Surv(popAges) ~ 1, dist = 'weibull')
#c(lifespanWeib$AIC, lifespanGomp$AIC, lifespanWeib$AIC - lifespanGomp$AIC )
#sOject = Surv(popAges)
#timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
#age.file.name=paste("cutoff", degreeCutoff, "p", p, "lambda", lambda, "time", timestamp, "txt", sep="." )
#write.csv( popAges, paste("simulated.ages/",age.file.name, sep=""), row.names=F)
#sim_names = c( "cutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
#sim = rbind(sim, c( degreeCutoff, p, lambda, mean(popAges), median(popAges),
#                    lifespanGomp$res[2,1], lifespanGomp$res[1,1], lifespanGomp$AIC, lifespanWeib$AIC))
} # end of p-loop
#timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
#write.csv(sim, file= paste(currentwkdir, "sce_sim_", timestamp, ".csv", sep=""), row.names=F)
} #end of lambda loop
#write.csv(sim, file="sceGINPPIaging_sim_2013121_end.csv", row.names=F)
#quite('yes')
# 2014 Feb 17, change name "20131221.DIPandGIN.sim.aging_v2.R" to "net-aging-sim-2014Feb17.R"
# 2013 Dec 20, merge DIP PPI and Genetic Inxt Net -> Multi-net approach
rm(list=ls())
require('flexsurv')
source("/Users/hongqin/lib/R/lifespan.r")
#source("lifespan.r")
#setwd("~/projects/0.network.aging.prj/0.ppi.reliability.simulation")
list.files(path='data', )
debug = 0;
#essential gene info
essenTb = read.csv('SummaryRegressionHetHom2013Oct29.csv', colClasses=rep('character', 9))
# remove self-intxns
currentwkdir = 'dipgin.ms02.output/1/'
currentmsfile = paste( 'dipgin.ms02.output/1/', 'ms02_1.tab',sep='' )
pairs = read.table(currentmsfile, sep ='\t', header=T, colClass=c('character','character',NA))
pairs = pairs[ pairs$id1 != pairs$id2, ]
#######################
# How do the two data set overlap? DIP seems to contain some questionable orfs
uniq.orf.from.pairs = unique(c(pairs$id1, pairs$id2)) #5496 ORF
matches = uniq.orf.from.pairs %in% unique(essenTb$orf)
table(matches)
unmatchedORF = uniq.orf.from.pairs[! matches]
matches = uniq.orf.from.pairs %in% unique(essenTb$orf[essenTb$essenflag=='essential'])
table(matches)
matches = uniq.orf.from.pairs %in% unique(essenTb$orf[essenTb$essenflag=='nonessential'])
table(matches)
#remove unmatched orfs from pairs
pairs$Removeflag = ifelse( pairs$id1 %in%unmatchedORF | pairs$id2 %in%unmatchedORF, T,F   )
table(pairs$Removeflag)
#So, the DIP+GIN.lenior lead to 572221 intxns
pairs = pairs[! pairs$Removeflag, ]
table(pairs$Removeflag)
pairs = pairs[,1:2]  ##This set of pairs is read for analysis
#write.table(pairs, "merged_PPIGIN_2014Jan20.tab", quote=F, row.names=F, col.names=F, sep='\t')
###############################
# label essential nodes, remove nonesse-nonessen pairs
essentialORFs = essenTb$orf[essenTb$essenflag=='essential']
pairs$essen1 = pairs$id1 %in% essentialORFs
pairs$essen2 = pairs$id2 %in% essentialORFs
head(pairs)
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove,1:4 ]
#Now, only 31394 intxn left for the original net
# 34052 for one ms02 network
#how many essen <--> essen intxn?
pairs$inxnEE = pairs$essen1 & pairs$essen2
table(pairs$inxnEE)
# FALSE  TRUE
# 28222  3172
#So, EE intxn should only occur in PPI
#for ms02,
#FALSE  TRUE
#33538   514
#How many essen genes?
tmp = essentialORFs %in% unique(c(pairs$id1, pairs$id2))
table(tmp)
#FALSE  TRUE
#110   1048
#104 1048 ???
essentialORFsPPI = essentialORFs[tmp] #?????
#get connectivities per node
degreeTb = data.frame( table(c(pairs[,1], pairs[,2])))
summary(degreeTb)
#median degree =5, mean=12
#for one ms02, media =6, mean=13.68, so orginal network is power-law like, skew at two ends.
degreeTb$ORF = as.character( degreeTb[,1])
#hist(log2(degreeTb$Freq), breaks=30)
degreeCutoff = 4; #######!!!!!! degree=5 is the median
tmp = essentialORFsPPI %in% degreeTb$ORF[degreeTb$Freq>degreeCutoff]
GooddEssentialORFsPPI = essentialORFsPPI[tmp]
###########################
if(debug >= 5){GooddEssentialORFsPPI = GooddEssentialORFsPPI[1:100]  }
###########################
# simulate aging
# -> exponential age to all pairs
# -> maximal age for each essential gene
# -> minimal age for all essential modules
#set.seed(2013)
#lambda_v = 1 / 3^seq(3,5)
#lambda_v = 1 / s
lambda_v = 1/c(27, 27*3)
# Notice that degree*p > 1 if the cells are to be alive. >2 should sufficient redundancy.
p_v = seq(0.7, 1.0, by=0.1)  ; #the chance that each gene interaction is active at t=0
#p_v = c(0.7, 0.7, 0.7,  0.8, 0.8, 0.8, 0.9, 0.9, 0.9, 1.0, 1.0, 1.0)  ; #the chance that each gene interaction is active at t=0
sim_names = c( "degreeCutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
sim       = t( c(NA,     NA,   NA,       NA,       NA,        NA,  NA,   NA,      NA))
sim = data.frame(sim)
names(sim) = sim_names
lambda = 1/35; p=0.9
currentNetworkAge = _single_network_failure(lambda, p, pairs, GoodEssentialORFsPPI)
currentNetworkAge = single_network_failure(lambda, p, pairs, GoodEssentialORFsPPI)
single_network_failure = function(lambda, p, pairs, runningORFs) {
# single network failure simulation
# lambda: exponential constant failure rate for edges
# pairs: network in pairwide format
# runningORFs: GooddEssentialORFsPPI
inpairs = pairs[,1:2] #bookkeeping
names(inpairs) = c('id1','id2')
#stochasticity into pairs
inpairs$active = runif(length(inpairs[,1]))  #uniform
# tmp = pairs$active > 1-p
# table(tmp) / length(tmp)  ; #double-check, very good.
inpairs$age = rexp( length(inpairs[,1]), rate=lambda )  #exponential ages for pairs
inpairs$age = ifelse(inpairs$active > (1-p), inpairs$age, NA ) #if not active, intxn is excluded.
#pairs$age = ifelse(pairs$active > (1-p), pairs$age, 0 )  # in what situations, can non-ative intxn be treat as 0-age?
ModuleTb = data.frame(runningORFs) #buffer for module ages
#loop every essential genes to identify the module age
for (i in 1:length(runningORFs)) {
myORF = runningORFs[i]
pos1 = grep(myORF, inpairs$id1)
pos2 = grep(myORF, inpairs$id2)  #id1,2 to ORF1,2 is a really bad choice.
if( length( c(pos1,pos2))>=1 ) {
ModuleTb$age.m[i] = max( inpairs$age[c(pos1,pos2)], na.rm=T )   #maximal intxn age -> module age
} else {
ModuleTb$age.m[i] = NA;
}
}
#head(ModuleTb);
summary(ModuleTb)
ModuleTb$age.m[ ModuleTb$age.m== -Inf] = 0; #dead births occur when links are not active
currentNetworkAge = min(ModuleTb$age.m)
}
currentNetworkAge = single_network_failure(lambda, p, pairs, GoodEssentialORFsPPI)
currentNetworkAge = single_network_failure(lambda, p, pairs, GooddEssentialORFsPPI)
currentNetworkAge = single_network_failure(lambda, p, pairs, GooddEssentialORFsPPI)
single_network_failure = function(lambda, p, pairs, runningORFs) {
# single network failure simulation
# lambda: exponential constant failure rate for edges
# pairs: network in pairwide format
# runningORFs: GooddEssentialORFsPPI
inpairs = pairs[,1:2] #bookkeeping
names(inpairs) = c('id1','id2')
#stochasticity into pairs
inpairs$active = runif(length(inpairs[,1]))  #uniform
# tmp = pairs$active > 1-p
# table(tmp) / length(tmp)  ; #double-check, very good.
inpairs$age = rexp( length(inpairs[,1]), rate=lambda )  #exponential ages for pairs
inpairs$age = ifelse(inpairs$active > (1-p), inpairs$age, NA ) #if not active, intxn is excluded.
#pairs$age = ifelse(pairs$active > (1-p), pairs$age, 0 )  # in what situations, can non-ative intxn be treat as 0-age?
ModuleTb = data.frame(runningORFs) #buffer for module ages
#loop every essential genes to identify the module age
for (i in 1:length(runningORFs)) {
myORF = runningORFs[i]
pos1 = grep(myORF, inpairs$id1)
pos2 = grep(myORF, inpairs$id2)  #id1,2 to ORF1,2 is a really bad choice.
if( length( c(pos1,pos2))>=1 ) {
ModuleTb$age.m[i] = max( inpairs$age[c(pos1,pos2)], na.rm=T )   #maximal intxn age -> module age
} else {
ModuleTb$age.m[i] = NA;
}
}
#head(ModuleTb);
summary(ModuleTb)
ModuleTb$age.m[ ModuleTb$age.m== -Inf] = 0; #dead births occur when links are not active
currentNetworkAge = min(ModuleTb$age.m)
}
# 2014 Feb 17, change name "20131221.DIPandGIN.sim.aging_v2.R" to "net-aging-sim-2014Feb17.R"
# 2013 Dec 20, merge DIP PPI and Genetic Inxt Net -> Multi-net approach
rm(list=ls())
require('flexsurv')
source("/Users/hongqin/lib/R/lifespan.r")
#source("lifespan.r")
#setwd("~/projects/0.network.aging.prj/0.ppi.reliability.simulation")
list.files(path='data', )
debug = 0;
#essential gene info
essenTb = read.csv('SummaryRegressionHetHom2013Oct29.csv', colClasses=rep('character', 9))
# remove self-intxns
currentwkdir = 'dipgin.ms02.output/1/'
currentmsfile = paste( 'dipgin.ms02.output/1/', 'ms02_1.tab',sep='' )
pairs = read.table(currentmsfile, sep ='\t', header=T, colClass=c('character','character',NA))
pairs = pairs[ pairs$id1 != pairs$id2, ]
#######################
# How do the two data set overlap? DIP seems to contain some questionable orfs
uniq.orf.from.pairs = unique(c(pairs$id1, pairs$id2)) #5496 ORF
matches = uniq.orf.from.pairs %in% unique(essenTb$orf)
table(matches)
unmatchedORF = uniq.orf.from.pairs[! matches]
matches = uniq.orf.from.pairs %in% unique(essenTb$orf[essenTb$essenflag=='essential'])
table(matches)
matches = uniq.orf.from.pairs %in% unique(essenTb$orf[essenTb$essenflag=='nonessential'])
table(matches)
#remove unmatched orfs from pairs
pairs$Removeflag = ifelse( pairs$id1 %in%unmatchedORF | pairs$id2 %in%unmatchedORF, T,F   )
table(pairs$Removeflag)
#So, the DIP+GIN.lenior lead to 572221 intxns
pairs = pairs[! pairs$Removeflag, ]
table(pairs$Removeflag)
pairs = pairs[,1:2]  ##This set of pairs is read for analysis
#write.table(pairs, "merged_PPIGIN_2014Jan20.tab", quote=F, row.names=F, col.names=F, sep='\t')
###############################
# label essential nodes, remove nonesse-nonessen pairs
essentialORFs = essenTb$orf[essenTb$essenflag=='essential']
pairs$essen1 = pairs$id1 %in% essentialORFs
pairs$essen2 = pairs$id2 %in% essentialORFs
head(pairs)
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove,1:4 ]
#Now, only 31394 intxn left for the original net
# 34052 for one ms02 network
#how many essen <--> essen intxn?
pairs$inxnEE = pairs$essen1 & pairs$essen2
table(pairs$inxnEE)
# FALSE  TRUE
# 28222  3172
#So, EE intxn should only occur in PPI
#for ms02,
#FALSE  TRUE
#33538   514
#How many essen genes?
tmp = essentialORFs %in% unique(c(pairs$id1, pairs$id2))
table(tmp)
#FALSE  TRUE
#110   1048
#104 1048 ???
essentialORFsPPI = essentialORFs[tmp] #?????
#get connectivities per node
degreeTb = data.frame( table(c(pairs[,1], pairs[,2])))
summary(degreeTb)
#median degree =5, mean=12
#for one ms02, media =6, mean=13.68, so orginal network is power-law like, skew at two ends.
degreeTb$ORF = as.character( degreeTb[,1])
#hist(log2(degreeTb$Freq), breaks=30)
degreeCutoff = 4; #######!!!!!! degree=5 is the median
tmp = essentialORFsPPI %in% degreeTb$ORF[degreeTb$Freq>degreeCutoff]
GooddEssentialORFsPPI = essentialORFsPPI[tmp]
###########################
if(debug >= 5){GooddEssentialORFsPPI = GooddEssentialORFsPPI[1:100]  }
###########################
# simulate aging
# -> exponential age to all pairs
# -> maximal age for each essential gene
# -> minimal age for all essential modules
#set.seed(2013)
#lambda_v = 1 / 3^seq(3,5)
#lambda_v = 1 / s
lambda_v = 1/c(27, 27*3)
# Notice that degree*p > 1 if the cells are to be alive. >2 should sufficient redundancy.
p_v = seq(0.7, 1.0, by=0.1)  ; #the chance that each gene interaction is active at t=0
#p_v = c(0.7, 0.7, 0.7,  0.8, 0.8, 0.8, 0.9, 0.9, 0.9, 1.0, 1.0, 1.0)  ; #the chance that each gene interaction is active at t=0
sim_names = c( "degreeCutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
sim       = t( c(NA,     NA,   NA,       NA,       NA,        NA,  NA,   NA,      NA))
sim = data.frame(sim)
names(sim) = sim_names
################################## network simulations
# for debug, lambda = 1/10
# lambda = 1/35; p=0.9
for(lambda in lambda_v) {
for( p in p_v) {  # p=0.9, #for debug
popSize = 10 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*100)) {
count = count + 1;
currentNetworkAge = single_network_failure(lambda, p, pairs, GooddEssentialORFsPPI)
#single_network_failure = function(lambda, p, pairs, runningORFs) {
if (currentNetworkAge > 0) {
popAges[j] = currentNetworkAge
j = j+1
}
}# end of j while-loop, population loop
#time2 = date()
#hist(popAges)
#summary(popAges)
#popAges = popAges[popAges>0]; #remove dead-births, which can occur when p is low
#time1; time2;
#s.tb = calculate.s ( popAges )
#plot( s.tb$s ~ s.tb$t )
#plot( s.tb$s ~ s.tb$t, type='l', log='x' )
#lifespanGomp = flexsurvreg(formula = Surv(popAges) ~ 1, dist = 'gompertz') ### Use the flexsurvreg package to fit lifespan data to gompertz or weibull distribution
#lifespanWeib = flexsurvreg(formula = Surv(popAges) ~ 1, dist = 'weibull')
#c(lifespanWeib$AIC, lifespanGomp$AIC, lifespanWeib$AIC - lifespanGomp$AIC )
#sOject = Surv(popAges)
#timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
#age.file.name=paste("cutoff", degreeCutoff, "p", p, "lambda", lambda, "time", timestamp, "txt", sep="." )
#write.csv( popAges, paste("simulated.ages/",age.file.name, sep=""), row.names=F)
#sim_names = c( "cutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
#sim = rbind(sim, c( degreeCutoff, p, lambda, mean(popAges), median(popAges),
#                    lifespanGomp$res[2,1], lifespanGomp$res[1,1], lifespanGomp$AIC, lifespanWeib$AIC))
} # end of p-loop
#timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
#write.csv(sim, file= paste(currentwkdir, "sce_sim_", timestamp, ".csv", sep=""), row.names=F)
} #end of lambda loop
#write.csv(sim, file="sceGINPPIaging_sim_2013121_end.csv", row.names=F)
#quite('yes')
# 2014 Feb 17, change name "20131221.DIPandGIN.sim.aging_v2.R" to "net-aging-sim-2014Feb17.R"
# 2013 Dec 20, merge DIP PPI and Genetic Inxt Net -> Multi-net approach
rm(list=ls())
require('flexsurv')
#source("/Users/hongqin/lib/R/lifespan.r")
source("lifespan.r")
#setwd("~/projects/0.network.aging.prj/0.ppi.reliability.simulation")
list.files(path='data', )
debug = 0;
#essential gene info
essenTb = read.csv('SummaryRegressionHetHom2013Oct29.csv', colClasses=rep('character', 9))
# remove self-intxns
currentwkdir = 'dipgin.ms02.output/1/'
currentmsfile = paste( 'dipgin.ms02.output/1/', 'ms02_1.tab',sep='' )
pairs = read.table(currentmsfile, sep ='\t', header=T, colClass=c('character','character',NA))
pairs = pairs[ pairs$id1 != pairs$id2, ]
#######################
# How do the two data set overlap? DIP seems to contain some questionable orfs
uniq.orf.from.pairs = unique(c(pairs$id1, pairs$id2)) #5496 ORF
matches = uniq.orf.from.pairs %in% unique(essenTb$orf)
table(matches)
unmatchedORF = uniq.orf.from.pairs[! matches]
matches = uniq.orf.from.pairs %in% unique(essenTb$orf[essenTb$essenflag=='essential'])
table(matches)
matches = uniq.orf.from.pairs %in% unique(essenTb$orf[essenTb$essenflag=='nonessential'])
table(matches)
#remove unmatched orfs from pairs
pairs$Removeflag = ifelse( pairs$id1 %in%unmatchedORF | pairs$id2 %in%unmatchedORF, T,F   )
table(pairs$Removeflag)
#So, the DIP+GIN.lenior lead to 572221 intxns
pairs = pairs[! pairs$Removeflag, ]
table(pairs$Removeflag)
pairs = pairs[,1:2]  ##This set of pairs is read for analysis
#write.table(pairs, "merged_PPIGIN_2014Jan20.tab", quote=F, row.names=F, col.names=F, sep='\t')
###############################
# label essential nodes, remove nonesse-nonessen pairs
essentialORFs = essenTb$orf[essenTb$essenflag=='essential']
pairs$essen1 = pairs$id1 %in% essentialORFs
pairs$essen2 = pairs$id2 %in% essentialORFs
head(pairs)
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove,1:4 ]
#Now, only 31394 intxn left for the original net
# 34052 for one ms02 network
#how many essen <--> essen intxn?
pairs$inxnEE = pairs$essen1 & pairs$essen2
table(pairs$inxnEE)
# FALSE  TRUE
# 28222  3172
#So, EE intxn should only occur in PPI
#for ms02,
#FALSE  TRUE
#33538   514
#How many essen genes?
tmp = essentialORFs %in% unique(c(pairs$id1, pairs$id2))
table(tmp)
#FALSE  TRUE
#110   1048
#104 1048 ???
essentialORFsPPI = essentialORFs[tmp] #?????
#get connectivities per node
degreeTb = data.frame( table(c(pairs[,1], pairs[,2])))
summary(degreeTb)
#median degree =5, mean=12
#for one ms02, media =6, mean=13.68, so orginal network is power-law like, skew at two ends.
degreeTb$ORF = as.character( degreeTb[,1])
#hist(log2(degreeTb$Freq), breaks=30)
degreeCutoff = 4; #######!!!!!! degree=5 is the median
tmp = essentialORFsPPI %in% degreeTb$ORF[degreeTb$Freq>degreeCutoff]
GooddEssentialORFsPPI = essentialORFsPPI[tmp]
###########################
if(debug >= 5){GooddEssentialORFsPPI = GooddEssentialORFsPPI[1:100]  }
###########################
# simulate aging
# -> exponential age to all pairs
# -> maximal age for each essential gene
# -> minimal age for all essential modules
#set.seed(2013)
#lambda_v = 1 / 3^seq(3,5)
#lambda_v = 1 / s
lambda_v = 1/c(27, 27*3)
# Notice that degree*p > 1 if the cells are to be alive. >2 should sufficient redundancy.
p_v = seq(0.7, 1.0, by=0.1)  ; #the chance that each gene interaction is active at t=0
#p_v = c(0.7, 0.7, 0.7,  0.8, 0.8, 0.8, 0.9, 0.9, 0.9, 1.0, 1.0, 1.0)  ; #the chance that each gene interaction is active at t=0
sim_names = c( "degreeCutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
sim       = t( c(NA,     NA,   NA,       NA,       NA,        NA,  NA,   NA,      NA))
sim = data.frame(sim)
names(sim) = sim_names
################################## network simulations
# for debug, lambda = 1/10
# lambda = 1/35; p=0.9
for(lambda in lambda_v) {
for( p in p_v) {  # p=0.9, #for debug
popSize = 10 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*100)) {
count = count + 1;
currentNetworkAge = single_network_failure(lambda, p, pairs, GooddEssentialORFsPPI)
#single_network_failure = function(lambda, p, pairs, runningORFs) {
if (currentNetworkAge > 0) {
popAges[j] = currentNetworkAge
j = j+1
}
}# end of j while-loop, population loop
#time2 = date()
#hist(popAges)
#summary(popAges)
#popAges = popAges[popAges>0]; #remove dead-births, which can occur when p is low
#time1; time2;
#s.tb = calculate.s ( popAges )
#plot( s.tb$s ~ s.tb$t )
#plot( s.tb$s ~ s.tb$t, type='l', log='x' )
#lifespanGomp = flexsurvreg(formula = Surv(popAges) ~ 1, dist = 'gompertz') ### Use the flexsurvreg package to fit lifespan data to gompertz or weibull distribution
#lifespanWeib = flexsurvreg(formula = Surv(popAges) ~ 1, dist = 'weibull')
#c(lifespanWeib$AIC, lifespanGomp$AIC, lifespanWeib$AIC - lifespanGomp$AIC )
#sOject = Surv(popAges)
#timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
#age.file.name=paste("cutoff", degreeCutoff, "p", p, "lambda", lambda, "time", timestamp, "txt", sep="." )
#write.csv( popAges, paste("simulated.ages/",age.file.name, sep=""), row.names=F)
#sim_names = c( "cutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
#sim = rbind(sim, c( degreeCutoff, p, lambda, mean(popAges), median(popAges),
#                    lifespanGomp$res[2,1], lifespanGomp$res[1,1], lifespanGomp$AIC, lifespanWeib$AIC))
} # end of p-loop
#timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
#write.csv(sim, file= paste(currentwkdir, "sce_sim_", timestamp, ".csv", sep=""), row.names=F)
} #end of lambda loop
