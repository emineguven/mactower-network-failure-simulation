summary(tb)
output$mean[i]=mean(tb$rls)
output$stddev[i]= sd(tb$rls)
output$CV[i] = sd(tb$rls) / mean(tb$rls)
fitGomp = flexsurvreg( formula=Surv(tb$rls) ~ 1, dist='gompertz')
Rhat = fitGomp$res[2,1]; Ghat = fitGomp$res[1,1]
output$Rflex[i] = Rhat; output$Gflex[i]=Ghat;
layout(matrix(c(1,2,3,4), 2, 2, byrow = TRUE))
#i=1;
for( i in 1:5) {
filename = paste('DR/', files[i], sep='')
tb = read.csv(filename)
summary(tb)
output$mean[i]=mean(tb$rls)
output$stddev[i]= sd(tb$rls)
output$CV[i] = sd(tb$rls) / mean(tb$rls)
fitGomp = flexsurvreg( formula=Surv(tb$rls) ~ 1, dist='gompertz')
Rhat = fitGomp$res[2,1]; Ghat = fitGomp$res[1,1]
output$Rflex[i] = Rhat; output$Gflex[i]=Ghat;
#G = (n-1) / t0, so t0 = (n-1)/G
nhat = 3; t0= (nhat-1)/Ghat; t0
fitBinom = optim ( c(Rhat, t0, nhat),  llh.binomialMortality.single.run , lifespan=tb$rls,
method="L-BFGS-B", lower=c(1E-10,0.05,1E-1), upper=c(10,100,50) );
output[i, c("R", "t0", "n")] = fitBinom$par
#  fitGomp2 = optim ( c(0.005, 0.08),  llh.G.single.run , lifespan=tb$rls,
#                    method="L-BFGS-B", lower=c(1E-10,1E-2), upper=c(10,10) );
tb2 = calculate.mortality.rate(tb$rls)
plot( tb2$s ~ tb2$t, main=filename)
plot( tb2$mortality.rate ~ tb2$t , main=filename)
plot( tb2$mortality.rate ~ tb2$t, log='y', main='linear for Gompertz' )
plot( tb2$mortality.rate ~ tb2$t, log='yx', main='linear for Weibull' )
}#i file loop
plot( output$R ~ output$glucose, type='l' )
plot( output$t0 ~ output$glucose,type='l', xlab="Glucose", ylab="t0" )
points( output$glucose, output$t0, pch=19)
plot( output$n ~ output$glucose,type='l', ylim=c(4.4,5.5), xlab='Glucose', ylab="n" )
points( output$glucose, output$n, pch=19)
plot( output$mean ~ output$glucose, type='l', xlab="Glucose",ylab="Mean RLS")
points( output$glucose, output$mean, pch=19)
plot( output$CV ~ output$glucose, type='l', xlab="Glucose", ylab="CV of RLS", ylim=c(0.35, 0.39) )
points(output$glucose, output$CV, pch=19)
plot( output$stddev ~ output$glucose, type='l')
plot( output$Rflex ~ output$glucose, type='l', xlab="Glucose",ylab="R")
points( output$glucose, output$Rflex, pch=19)
plot( output$Gflex ~ output$glucose, type='l', xlab="Glucose",ylab="G")
points( output$glucose, output$Gflex, pch=19)
}
#i=1;
for( i in 1:5) {
filename = paste('DR/', files[i], sep='')
tb = read.csv(filename)
summary(tb)
output$mean[i]=mean(tb$rls)
output$stddev[i]= sd(tb$rls)
output$CV[i] = sd(tb$rls) / mean(tb$rls)
fitGomp = flexsurvreg( formula=Surv(tb$rls) ~ 1, dist='gompertz')
Rhat = fitGomp$res[2,1]; Ghat = fitGomp$res[1,1]
output$Rflex[i] = Rhat; output$Gflex[i]=Ghat;
#G = (n-1) / t0, so t0 = (n-1)/G
nhat = 3; t0= (nhat-1)/Ghat; t0
fitBinom = optim ( c(Rhat, t0, nhat),  llh.binomialMortality.single.run , lifespan=tb$rls,
method="L-BFGS-B", lower=c(1E-10,0.05,1E-1), upper=c(10,100,50) );
output[i, c("R", "t0", "n")] = fitBinom$par
#  fitGomp2 = optim ( c(0.005, 0.08),  llh.G.single.run , lifespan=tb$rls,
#                    method="L-BFGS-B", lower=c(1E-10,1E-2), upper=c(10,10) );
tb2 = calculate.mortality.rate(tb$rls)
plot( tb2$s ~ tb2$t, main=filename)
plot( tb2$mortality.rate ~ tb2$t , main=filename)
plot( tb2$mortality.rate ~ tb2$t, log='y', main='linear for Gompertz' )
plot( tb2$mortality.rate ~ tb2$t, log='yx', main='linear for Weibull' )
}#i file loop
require(flexsurv)
#i=1;
for( i in 1:5) {
filename = paste('DR/', files[i], sep='')
tb = read.csv(filename)
summary(tb)
output$mean[i]=mean(tb$rls)
output$stddev[i]= sd(tb$rls)
output$CV[i] = sd(tb$rls) / mean(tb$rls)
fitGomp = flexsurvreg( formula=Surv(tb$rls) ~ 1, dist='gompertz')
Rhat = fitGomp$res[2,1]; Ghat = fitGomp$res[1,1]
output$Rflex[i] = Rhat; output$Gflex[i]=Ghat;
#G = (n-1) / t0, so t0 = (n-1)/G
nhat = 3; t0= (nhat-1)/Ghat; t0
fitBinom = optim ( c(Rhat, t0, nhat),  llh.binomialMortality.single.run , lifespan=tb$rls,
method="L-BFGS-B", lower=c(1E-10,0.05,1E-1), upper=c(10,100,50) );
output[i, c("R", "t0", "n")] = fitBinom$par
#  fitGomp2 = optim ( c(0.005, 0.08),  llh.G.single.run , lifespan=tb$rls,
#                    method="L-BFGS-B", lower=c(1E-10,1E-2), upper=c(10,10) );
tb2 = calculate.mortality.rate(tb$rls)
plot( tb2$s ~ tb2$t, main=filename)
plot( tb2$mortality.rate ~ tb2$t , main=filename)
plot( tb2$mortality.rate ~ tb2$t, log='y', main='linear for Gompertz' )
plot( tb2$mortality.rate ~ tb2$t, log='yx', main='linear for Weibull' )
}#i file loop
#test binomial aging model on glucose dose in BY4742
rm(list=ls());
setwd("~/github/0.network.aging.prj/0a.network.fitting")
source("lifespan.20140711.r")
require(flexsurv)
#files = list.files(, path='DR', pattern="BY4742")
files = c(
"BY4742_MATalpha_temp30_media_0.005% D_n299.csv",
"BY4742_MATalpha_temp30_media_0.05% D_n4690.csv",
"BY4742_MATalpha_temp30_media_0.1% D_n338.csv",
"BY4742_MATalpha_temp30_media_0.5% D_n579.csv",
"BY4742_MATalpha_temp30_media_YPD_n19930.csv"
);
i=1; filename = paste('DR/', files[i], sep='');  tb = read.csv(filename)
s1 = calculate.s(tb$rls); s1=rbind(c(1,0), s1)
i=2; filename = paste('DR/', files[i], sep='');  tb = read.csv(filename)
s2 = calculate.s(tb$rls); s2=rbind(c(1,0),s2);
i=3; filename = paste('DR/', files[i], sep='');  tb = read.csv(filename)
s3 = calculate.s(tb$rls); s3=rbind(c(1,0),s3);
i=4; filename = paste('DR/', files[i], sep='');  tb = read.csv(filename)
s4 = calculate.s(tb$rls); s4=rbind(c(1,0), s4);
i=5; filename = paste('DR/', files[i], sep='');  tb = read.csv(filename)
s5 = calculate.s(tb$rls); s5=rbind(c(1,0), s5)
plot( s1$s ~ s1$t, xlim=c(10,40), type='l', col='red', )
lines(s2$s ~ s2$t, col='orange')
lines(s3$s ~ s3$t, col='blue')
lines(s4$s ~ s4$t, col='green')
lines(s5$s ~ s5$t, col='black')
output = data.frame(files);
output$mean = NA; output$stddev = NA; output$CV=NA;
output$R=NA; output$t0=NA; output$n=NA;
output$Rflex = NA; output$Gflex = NA;
output$glucose = c(0.005, 0.05, 0.1, 0.5, 2.0)
#pdf("BY4742GlucoseDose-binomial-20140713.pdf", width=10, height=8)
layout(matrix(c(1,2,3,4), 2, 2, byrow = TRUE))
#i=1;
for( i in 1:5) {
filename = paste('DR/', files[i], sep='')
tb = read.csv(filename)
summary(tb)
output$mean[i]=mean(tb$rls)
output$stddev[i]= sd(tb$rls)
output$CV[i] = sd(tb$rls) / mean(tb$rls)
fitGomp = flexsurvreg( formula=Surv(tb$rls) ~ 1, dist='gompertz')
Rhat = fitGomp$res[2,1]; Ghat = fitGomp$res[1,1]
output$Rflex[i] = Rhat; output$Gflex[i]=Ghat;
#G = (n-1) / t0, so t0 = (n-1)/G
nhat = 3; t0= (nhat-1)/Ghat; t0
fitBinom = optim ( c(Rhat, t0, nhat),  llh.binomialMortality.single.run , lifespan=tb$rls,
method="L-BFGS-B", lower=c(1E-10,0.05,1E-1), upper=c(10,100,50) );
output[i, c("R", "t0", "n")] = fitBinom$par
#  fitGomp2 = optim ( c(0.005, 0.08),  llh.G.single.run , lifespan=tb$rls,
#                    method="L-BFGS-B", lower=c(1E-10,1E-2), upper=c(10,10) );
tb2 = calculate.mortality.rate(tb$rls)
plot( tb2$s ~ tb2$t, main=filename)
plot( tb2$mortality.rate ~ tb2$t , main=filename)
plot( tb2$mortality.rate ~ tb2$t, log='y', main='linear for Gompertz' )
plot( tb2$mortality.rate ~ tb2$t, log='yx', main='linear for Weibull' )
}#i file loop
plot( output$R ~ output$glucose, type='l' )
plot( output$t0 ~ output$glucose,type='l', xlab="Glucose", ylab="t0" )
points( output$glucose, output$t0, pch=19)
plot( output$n ~ output$glucose,type='l', ylim=c(4.4,5.5), xlab='Glucose', ylab="n" )
points( output$glucose, output$n, pch=19)
plot( output$mean ~ output$glucose, type='l', xlab="Glucose",ylab="Mean RLS")
points( output$glucose, output$mean, pch=19)
plot( output$CV ~ output$glucose, type='l', xlab="Glucose", ylab="CV of RLS", ylim=c(0.35, 0.39) )
points(output$glucose, output$CV, pch=19)
plot( output$stddev ~ output$glucose, type='l')
plot( output$Rflex ~ output$glucose, type='l', xlab="Glucose",ylab="R")
points( output$glucose, output$Rflex, pch=19)
plot( output$Gflex ~ output$glucose, type='l', xlab="Glucose",ylab="G")
points( output$glucose, output$Gflex, pch=19)
#dev.off()
#q('no')
####END of 20140712 #########
?rep
rep(0,5)
inNetworkFile = 'net1/Degree4N1000_network.csv'
inLookupTbFile = 'net1/Degree4N1000_EssenLookupTb.csv'
lambda1 = 0.002
lambda2 = lambda1/10
p=1.0
source( 'network.r' )
library(foreach)
library(doMC)
library(GetoptLong)
p=probability;
list.files(path=outputdir )
registerDoMC(cores=inputCores)
essenLookupTb = read.csv(inLookupTbFile, row.names=1);
essenLookupTb = as.vector(essenLookupTb[,1]); #20151215 after update to R3.2.3
setwd("~/github/mactower-network-failure-simulation/1.grid.network.2015Oct")
essenLookupTb = read.csv(inLookupTbFile, row.names=1);
essenLookupTb = as.vector(essenLookupTb[,1]); #20151215 after update to R3.2.3
pairs = read.csv(inNetworkFile);
names(pairs) = c("No1", "No2")
print(head(pairs))
if(debug==9) {     pairs = pairs[1:1000,]  }
pairs = pairs[ pairs$No1 != pairs$No2, ]
# label essential nodes, remove nonesse-nonessen pairs
pairs$essen1 = essenLookupTb[pairs$No1]
pairs$essen2 = essenLookupTb[pairs$No2]
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove, ]
#get connectivities per node
degreeTb = data.frame( table(c(pairs$No1, pairs$No2)))
summary(degreeTb);
degreeTb[1:10,]
summary(degreeTb)
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
bufferAges = rep(0, inputCores); #20151230 change for parallel
popSize = 100;
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
bufferAges = rep(0, inputCores); #20151230 change for parallel
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
bufferAges = rep(0, inputCores*5); #20151230 change for parallel
inputCores=4
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
bufferAges = rep(0, inputCores*5); #20151230 change for parallel
j
foreach(i=1:inputCores*5) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
source( 'network.r' )
foreach(i=1:inputCores*5) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
degreeThreshold = 0;
foreach(i=1:inputCores*5) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
foreach(i=1: (inputCores*5)) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
bufferAges = rep(0, inputCores*5); #20151230 change for parallel
foreach(i=1: (inputCores*5)) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
goodAges = bufferAges [bufferAges>0]
bufferAges = rep(0, inputCores*5); #20151230 change for parallel
foreach(i=1: (inputCores*5)) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
goodAges = bufferAges [bufferAges>0]
goodAges = bufferAges [bufferAges>0]
foreach(i=1: (inputCores*5)) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
goodAges = bufferAges [bufferAges>0]
count = count + inputCores*5
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
}
if(debug) { print(paste("netwk_aging_sim::count=",count, "  j=", j))}
if(debug>0) { print(paste("netwk_aging_sim::count=",count, "  j=", j))}
debug
debug=1
if(debug) { print(paste("netwk_aging_sim::count=",count, "  j=", j))}
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*5)) {
bufferAges = rep(0, inputCores*5); #20151230 change for parallel
foreach(i=1: (inputCores*5)) %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
bufferAges[i] = currentNetworkAge
}
}
goodAges = bufferAges [bufferAges>0]
count = count + inputCores*5
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
}
if(debug) { print(paste("netwk_aging_sim::count=",count, "  j=", j))}
}# end of j while-loop, population loop
popAges
mean(popAges)
lambda1
bufferAges
bufferAges[bufferAges>0]
library(doMC)
registerDoMC(2)
foreach(i=1:3) %dopar% sqrt(i)
library(foreach)
library(doMC)
registerDoMC(2)
foreach(i=1:(3*2)) %dopar% sqrt(i)
library(foreach)
library(doMC)
registerDoMC(2)
x = foreach(i=1:(3*2)) %dopar% sqrt(i)
x
x2 = foreach(i=1:(3*2, .combine='cbind')) %dopar% sqrt(i)
x2
x2 = foreach(i=1:(3*2), .combine='cbind')) %dopar% sqrt(i)
x2
x2 = foreach(i=1:(3*2), .combine='cbind') %dopar% sqrt(i)
x2
inNetworkFile = 'net1/Degree4N1000_network.csv'
inLookupTbFile = 'net1/Degree4N1000_EssenLookupTb.csv'
lambda1 = 0.006
lambda2 = lambda1/10
p=1.0
popSize = 100;
inputCores=4
degreeThreshold = 0;
p=probability;
list.files(path=outputdir )
registerDoMC(cores=inputCores)
essenLookupTb = read.csv(inLookupTbFile, row.names=1);
essenLookupTb = as.vector(essenLookupTb[,1]); #20151215 after update to R3.2.3
pairs = read.csv(inNetworkFile);
names(pairs) = c("No1", "No2")
print(head(pairs))
if(debug==9) {     pairs = pairs[1:1000,]  }
pairs = pairs[ pairs$No1 != pairs$No2, ]
# label essential nodes, remove nonesse-nonessen pairs
pairs$essen1 = essenLookupTb[pairs$No1]
pairs$essen2 = essenLookupTb[pairs$No2]
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove, ]
#get connectivities per node
degreeTb = data.frame( table(c(pairs$No1, pairs$No2)))
summary(degreeTb);
j=1
myParrallStep = inputCores * 5
bufferAges = foreach(i=1:myParrallStep, .combine = 'cbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
goodAges = bufferAges [bufferAges>0] #goodAges() return NULL?
count = count + myParrallStep
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
} else {
print(paste("newk_aging_sim:: goodAges", goodAges))
}
if(debug>2) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
}
if(debug) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
print(paste("netwk_aging_sim::count=",count, "  j=", j))
}
source('~/github/mactower-network-failure-simulation/1.grid.network.2015Oct/netwk_aging_sim.v0.1b.R', echo=TRUE)
bufferAges
myParrallStep = inputCores * 5
bufferAges = foreach(i=1:myParrallStep, .combine = 'cbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
while ((j <= popSize) && ( count < popSize*5)) {
myParrallStep = inputCores * 5
bufferAges = foreach(i=1:myParrallStep, .combine = 'cbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
goodAges = bufferAges [bufferAges>0] #goodAges() return NULL?
count = count + myParrallStep
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
} else {
print(paste("newk_aging_sim:: goodAges", goodAges))
}
if(debug>2) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
}
if(debug) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
print(paste("netwk_aging_sim::count=",count, "  j=", j))
}
}# end of j while-loop, population loop
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*5)) {
myParrallStep = inputCores * 5
bufferAges = foreach(i=1:myParrallStep, .combine = 'cbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
goodAges = bufferAges [bufferAges>0] #goodAges() return NULL?
count = count + myParrallStep
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
} else {
print(paste("newk_aging_sim:: goodAges", goodAges))
}
if(debug>2) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
}
if(debug) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
print(paste("netwk_aging_sim::count=",count, "  j=", j))
}
}# end of j while-loop, population loop
inNetworkFile = 'net1/Degree4N1000_network.csv'
inLookupTbFile = 'net1/Degree4N1000_EssenLookupTb.csv'
lambda1 = 0.006
lambda2 = lambda1/10
p=1.0
popSize = 100;
inputCores=4
degreeThreshold = 0;
p=probability;
list.files(path=outputdir )
registerDoMC(cores=inputCores)
essenLookupTb = read.csv(inLookupTbFile, row.names=1);
essenLookupTb = as.vector(essenLookupTb[,1]); #20151215 after update to R3.2.3
pairs = read.csv(inNetworkFile);
names(pairs) = c("No1", "No2")
print(head(pairs))
if(debug==9) {     pairs = pairs[1:1000,]  }
pairs = pairs[ pairs$No1 != pairs$No2, ]
# label essential nodes, remove nonesse-nonessen pairs
pairs$essen1 = essenLookupTb[pairs$No1]
pairs$essen2 = essenLookupTb[pairs$No2]
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove, ]
#get connectivities per node
degreeTb = data.frame( table(c(pairs$No1, pairs$No2)))
summary(degreeTb);
degreeTb[1:10,]
summary(degreeTb)
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*5)) {
myParrallStep = inputCores * 5
bufferAges = foreach(i=1:myParrallStep, .combine = 'cbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
goodAges = bufferAges [bufferAges>0] #goodAges() return NULL?
count = count + myParrallStep
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
} else {
print(paste("newk_aging_sim:: goodAges", goodAges))
}
if(debug>2) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
}
if(debug) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
print(paste("netwk_aging_sim::count=",count, "  j=", j))
}
}# end of j while-loop, population loop
myParrallStep = inputCores * 5
bufferAges = foreach(i=1:myParrallStep, .combine = 'cbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
bufferAges
str(bufferAges)
goodAges = bufferAges [bufferAges>0] #goodAges() return NULL?
goodAges
if( length(goodAges)> 0 ){
currentEnd = j + length(goodAges)-1
popAges[j:currentEnd] = goodAges
j = currentEnd + 1
} else {
print(paste("newk_aging_sim:: goodAges", goodAges))
}
if(debug>2) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
}
if(debug) {
print(paste("netwk_aging_sim::bufferAges=",bufferAges))
print(paste("netwk_aging_sim::count=",count, "  j=", j))
}
View(bufferAges)
bufferAges = foreach(i=1:myParrallStep, .combine = 'rbind') %dopar% {
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeThreshold, p, pairs, essenLookupTb)
}
View(bufferAges)
goodAges = bufferAges [bufferAges>0] #goodAges() return NULL?
View(bufferAges)
