active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active>=p, 1, NA  )
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
i
#get connectivities per node
degreeTb = data.frame( table(c(inpairs$No1, inpairs$No2)))
names(degreeTb) = c("No", "degree")
degreeTb$moduleAge = NA;
#degreeTb = degreeTb[1:10,]
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active>=p, 1, NA  )
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
warnings()
View(degreeTb)
lambda1 = 1/100; lambda2=1E-5; threshold=4; p=0.8
#degreeTb = degreeTb[1:10,]
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active>=p, 1, NA  )
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
warnigns()
warnings()
View(degreeTb)
age
#degreeTb = degreeTb[1:10,]
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active<=p, 1, NA  )
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
age
View(degreeTb)
active
sum(active)
sum(active, na.rm=T)
active=c(NA, NA)
sum(active, na.rm=T)
#degreeTb = degreeTb[1:10,]
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active<=p, 1, NA  ) #pick active interactions
if( sum(active, na.rm=T) > 0 ){ #there should be at least 1 active intxn
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else {# when no active intxn is available
degreeTb$moduleAge[i] = 0; #this module is born dead.
}
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
View(degreeTb)
lambda1 = 1/50; lambda2=1E-5; threshold=4; p=0.8
inpairs = pairs[,3:4] #bookkeeping
names(inpairs) = c('No1','No2')
#get connectivities per node
degreeTb = data.frame( table(c(inpairs$No1, inpairs$No2)))
names(degreeTb) = c("No", "degree")
degreeTb$moduleAge = NA;
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active<=p, 1, NA  ) #pick active interactions
if( sum(active, na.rm=T) > 0 ){ #there should be at least 1 active intxn
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else {# when no active intxn is available
degreeTb$moduleAge[i] = 0; #this module is born dead.
}
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
View(degreeTb)
summary(degreeTb)
currentNetworkAge = min(degreeTb$moduleAge, na.rm=T)
View(degreeTb)
popSize = 5 #too small pop size and too small p can lead to very few living individuals
popSize = 5 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
popSize = 5 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, cutoff, p, pairs, essenLookupTb)
single_network_failure_v2 = function(lambda1, lambda2=lambda1/10, threshold=4, p, pairs, essenLookupTb ) {
# single network failure simulation, 20151013Tue
# lambda1: First exponential constant failure rate for edges with degree > threshold
# lambda2: Second exponential constant failure rate for edges with degree <= threshold
# threshold: degree threshold for lambda1 and lambda2
# pairs: network in pairwide format, using numeric NOs 20151013
# essenLookupTb: lookup table for essential and nonessential genes, numeric values
## for debug:   lambda1 = 1/50; lambda2= lambda1/10; threshold=4; p=0.8
inpairs = pairs[,3:4] #bookkeeping
names(inpairs) = c('No1','No2')
#get connectivities per node
degreeTb = data.frame( table(c(inpairs$No1, inpairs$No2)))
names(degreeTb) = c("No", "degree")
degreeTb$moduleAge = NA;
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active<=p, 1, NA  ) #pick active interactions
if( sum(active, na.rm=T) > 0 ){ #there should be at least 1 active intxn
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else {# when no active intxn is available
degreeTb$moduleAge[i] = 0; #this module is born dead.
}
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
summary(degreeTb)
currentNetworkAge = min(degreeTb$moduleAge, na.rm=T)
}
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
degreeCutoff = 4; #######!!!!!! degree=5 is the median
full_age_dir = "ori.ginppit.2015Oct"
popSize = 5 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
popSize = 5 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*30)) {
count = count + 1;
print(paste("count=",count))
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
popAges[j] = currentNetworkAge
j = j+1
}
}# end of j while-loop, population loop
single_network_failure_v2 = function(lambda1, lambda2=lambda1/10, threshold=4, p, pairs, essenLookupTb ) {
# single network failure simulation, 20151013Tue
# lambda1: First exponential constant failure rate for edges with degree > threshold
# lambda2: Second exponential constant failure rate for edges with degree <= threshold
# threshold: degree threshold for lambda1 and lambda2
# pairs: network in pairwide format, using numeric NOs 20151013
# essenLookupTb: lookup table for essential and nonessential genes, numeric values
## for debug:   lambda1 = 1/50; lambda2= lambda1/10; threshold=4; p=0.8
inpairs = pairs[,3:4] #bookkeeping
names(inpairs) = c('No1','No2')
#get connectivities per node
degreeTb = data.frame( table(c(inpairs$No1, inpairs$No2)))
names(degreeTb) = c("No", "degree")
degreeTb$moduleAge = NA;
for( i in 1:length(degreeTb[,1])){
if ( essenLookupTb[ degreeTb$No[i] ]) { #essential node
lambda = ifelse( degreeTb$degree[i] >= threshold, lambda1, lambda2)
age = rexp( degreeTb$degree[i], rate=lambda ) #exponential age
if(degreeTb$degree[i] >= threshold){
active = runif(degreeTb$degree[i])  #uniform interaction stochasticity
active = ifelse( active<=p, 1, NA  ) #pick active interactions
if( sum(active, na.rm=T) > 0 ){ #there should be at least 1 active intxn
age = age * active # only active interactions for modular age estimation
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
} else {# when no active intxn is available
degreeTb$moduleAge[i] = 0; #this module is born dead.
}
} else { # for degree < threshold, no stochasticity is applied.
degreeTb$moduleAge[i] = max(age, na.rm=T) #maximum intxn age is the module age
}
} else {# non-essential node
degreeTb$moduleAge[i] = NA
}
}
summary(degreeTb)
currentNetworkAge = min(degreeTb$moduleAge, na.rm=T)
}
##########################################
#2015Oct13, use numeric lookup table for essential genes.
#2014March3, redo ginppi simulation witht same parameter for ms02networks.
# 2014 Feb 17, change name "20131221.DIPandGIN.sim.aging_v2.R" to "net-aging-sim-2014Feb17.R"
# 2013 Dec 20, merge DIP PPI and Genetic Inxt Net -> Multi-net approach
rm(list=ls())
#require('flexsurv')
#source("lifespan.r")
#source("network.r")
list.files(path='data', )
debug = 0;
#essential gene info
essenTb = read.csv("data/SummaryRegressionHetHomFactorized2015Oct13.csv", colClasses=rep('character', 9))
essenLookupTb = read.csv("data/essntialGeneLookupTable_20151013.csv", row.names=1)
essenLookupTb = essenLookupTb[,1]
infile = "data/merged_PPIGIN_Factorized2015Oct13.csv"
pairs = read.csv(infile)
names(pairs) = c("id1",'id2', "No1", "No2")
print(head(pairs))
if(debug==9) {     pairs = pairs[1:1000,]  }
pairs = pairs[ pairs$No1 != pairs$No2, ]
# label essential nodes, remove nonesse-nonessen pairs
pairs$essen1 = essenLookupTb[pairs$No1]
pairs$essen2 = essenLookupTb[pairs$No2]
#remove nonessen <-> nonessen intxn because they do not affect aging.
pairs$remove = ifelse( pairs$essen1==F & pairs$essen2==F, T, F  )
pairs= pairs[! pairs$remove, ]
# 31394 for one ms02 network
#get connectivities per node
degreeTb = data.frame( table(c(pairs$No1, pairs$No2)))
summary(degreeTb);
degreeTb[1:10,]
#median degree =5, mean=12
#for one ms02, media =6, mean=13.68, so orginal network is power-law like, skew at two ends.
degreeCutoff = 4; #######!!!!!! degree=5 is the median
#lambda_v = 1/c(100, 50, 25 ) #2014Feb 25, fix double inverse bug in lambda
#p_v = seq(0.6, 1.0, by=0.1)  ; #the chance that each gene interaction is active at t=0
#sim_names = c( "degreeCutoff","p", "lambda", "meanLS", "medianLS", "R","G", "GompAIC", "WeibAIC")
#sim       = t( c(NA,     NA,   NA,       NA,       NA,        NA,  NA,   NA,      NA))
#sim = data.frame(sim)
#names(sim) = sim_names
full_age_dir = "ori.ginppit.2015Oct"
popSize = 50 #too small pop size and too small p can lead to very few living individuals
popAges = numeric(popSize)
time1 = date()
j=1; count = 0;
while ((j <= popSize) && ( count < popSize*30)) {
count = count + 1;
print(paste("count=",count))
currentNetworkAge = single_network_failure_v2(lambda1, lambda2, degreeCutoff, p, pairs, essenLookupTb)
if (currentNetworkAge > 0) {
popAges[j] = currentNetworkAge
j = j+1
}
<<<<<<< HEAD
}# end of j while-loop, population loop
timestamp = format(Sys.time(), "%Y%b%d_%H%M%S")
age.file.name=paste("threshold", degreeCutoff, "p", p, "lambda1", lambda1,
"lambda2", lambda2,'popsize',popSize, "time",timestamp, "txt", sep="." )
full_age_file = paste( full_age_dir,'/', age.file.name, sep='')
write.csv( popAges, full_age_file, row.names=F)
=======
degree=4; numOfNodes=1000; outfilename = "__test.csv"
degree=4; numOfEssenNodes=1000; outNetworkFile = "__test.csv"; outEssenLookupTb="__EssenLookupTb.csv"
debug = 0;
essenLookupTb = c(rep(1,numOfEssenNodes), rep(0, numOfEssenNodes*degree))
rm(list=ls())
debug = 0;
essenLookupTb = c(rep(1,numOfEssenNodes), rep(0, numOfEssenNodes*degree))
degree=4; numOfEssenNodes=1000; outNetworkFile = "__test.csv"; outEssenLookupTb="__EssenLookupTb.csv"
essenLookupTb = c(rep(1,numOfEssenNodes), rep(0, numOfEssenNodes*degree))
table(essenLookupTb)
essenLookupTb
pairs = data.frame()
pairs = data.frame()
pairs$id1 = NA
pairs$id2 = NA
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
View(pairs)
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
names(pairs) = c("No1","No2")
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
names(pairs) = c("No1","No2")
for( i in 1:length(numOfEssenNodes)) {
for( j in 1:degree){
pairs$No1[i+j-1] = i;
pairs$No2[i+j-1] = numOfEssenNodes + (i-1)*degree + i
}
}
View(pairs)
for( i in 1:length(numOfEssenNodes)) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row + numOfEssenNodes
}
}
View(pairs)
i
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row + numOfEssenNodes
}
}
View(pairs)
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row +j-1] + numOfEssenNodes
}
}
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row +j-1 + numOfEssenNodes
}
}
View(pairs)
table( paris$No1)
table( paris$No1)
table( pairs$No1)
str( table( pairs$No1))
table( pairs$No2)
table( pairs$No2)[1:10]
table( pairs$No1)[1:10]
length(unique(pairs[,1]))
length(unique(pairs[,1]))
length(unique(pairs[,2]))
write.csv(pairs, outNetworkFile, row.names = F)
##########################################
# generate gride network for simulation and quality control
rm(list=ls())
debug = 0;
# R -f file --args Degree numOfEssenNode outNetworkFile outEssenLookupTb
# R -f 20151013-net-sim-ginppi.R --args 4 1000 _Degree4N1000_network.csv _Degree4N100_EssenLookupTb.csv
options(echo=TRUE) # if you want see commands in output file
args <- commandArgs(trailingOnly = TRUE)
print(args)
degree = as.numeric(args[1]); degree;
numOfEssenNodes = as.numeric(args[2]); numOfNodes;
outNetworkFile = args[3]
outEssenLookupTb = args[4]
#for debug
# degree=4; numOfEssenNodes=1000; outNetworkFile = "__test.csv"; outEssenLookupTb="__EssenLookupTb.csv"
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
names(pairs) = c("No1","No2")
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row +j-1 + numOfEssenNodes
}
}
<<<<<<< Updated upstream
degree=4; numOfNodes=1000; outfilename = "__test.csv"
degree=4; numOfEssenNodes=1000; outNetworkFile = "__test.csv"; outEssenLookupTb="__EssenLookupTb.csv"
debug = 0;
essenLookupTb = c(rep(1,numOfEssenNodes), rep(0, numOfEssenNodes*degree))
rm(list=ls())
debug = 0;
essenLookupTb = c(rep(1,numOfEssenNodes), rep(0, numOfEssenNodes*degree))
degree=4; numOfEssenNodes=1000; outNetworkFile = "__test.csv"; outEssenLookupTb="__EssenLookupTb.csv"
essenLookupTb = c(rep(1,numOfEssenNodes), rep(0, numOfEssenNodes*degree))
table(essenLookupTb)
essenLookupTb
pairs = data.frame()
pairs = data.frame()
pairs$id1 = NA
pairs$id2 = NA
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
View(pairs)
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
names(pairs) = c("No1","No2")
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
names(pairs) = c("No1","No2")
for( i in 1:length(numOfEssenNodes)) {
for( j in 1:degree){
pairs$No1[i+j-1] = i;
pairs$No2[i+j-1] = numOfEssenNodes + (i-1)*degree + i
}
}
View(pairs)
for( i in 1:length(numOfEssenNodes)) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row + numOfEssenNodes
}
}
View(pairs)
i
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row + numOfEssenNodes
}
}
View(pairs)
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row +j-1] + numOfEssenNodes
}
}
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row +j-1 + numOfEssenNodes
}
}
View(pairs)
table( paris$No1)
table( paris$No1)
table( pairs$No1)
str( table( pairs$No1))
table( pairs$No2)
table( pairs$No2)[1:10]
table( pairs$No1)[1:10]
length(unique(pairs[,1]))
length(unique(pairs[,1]))
length(unique(pairs[,2]))
write.csv(pairs, outNetworkFile, row.names = F)
##########################################
# generate gride network for simulation and quality control
rm(list=ls())
debug = 0;
# R -f file --args Degree numOfEssenNode outNetworkFile outEssenLookupTb
# R -f 20151013-net-sim-ginppi.R --args 4 1000 _Degree4N1000_network.csv _Degree4N100_EssenLookupTb.csv
options(echo=TRUE) # if you want see commands in output file
args <- commandArgs(trailingOnly = TRUE)
print(args)
degree = as.numeric(args[1]); degree;
numOfEssenNodes = as.numeric(args[2]); numOfNodes;
outNetworkFile = args[3]
outEssenLookupTb = args[4]
#for debug
# degree=4; numOfEssenNodes=1000; outNetworkFile = "__test.csv"; outEssenLookupTb="__EssenLookupTb.csv"
pairs = data.frame(integer(numOfEssenNodes*degree), integer(numOfEssenNodes*degree))
names(pairs) = c("No1","No2")
for( i in 1:numOfEssenNodes) {
current_i_row = (i-1)*degree + 1
for( j in 1:degree){
pairs$No1[current_i_row +j-1] = i;
pairs$No2[current_i_row +j-1] = current_i_row +j-1 + numOfEssenNodes
}
}
=======
>>>>>>> Stashed changes
# check
table( pairs$No1)[1:10]
table( pairs$No2)[1:10]
length(unique(pairs[,1]))
length(unique(pairs[,2]))
write.csv(pairs, outNetworkFile, row.names = F)
outEssenLookupTb = c(rep(1, numOfEssenNodes), rep(0, numOfEssenNodes*degree))
<<<<<<< Updated upstream
=======
>>>>>>> origin/master
>>>>>>> Stashed changes
